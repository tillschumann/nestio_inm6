%--------------------------------------------------------------------------------
\documentclass[]{YIC2015}

% --------------------------------------------------------------------------------
% Include here your latex packages
%--------------------------------------------------------------------------------
\usepackage{graphicx}
\usepackage{color}
\usepackage{url}
\usepackage{subcaption}
% --------------------------------------------------------------------------------
% Article's title, with capital letter only at the beginning
%--------------------------------------------------------------------------------
\title{Modeling the I/O behavior of the NEST simulator using a proxy}

% -------------------------------------------------------------------------------
% List of authors
% --------------------------------------------------------------------------------
% Put the initials and surname of the first author ('et al.' if applicable) in
% square brackets before the command \author
%
% Identify the corresponding author with the command \corref and each author
% with the command \authref{a,b,...} according to the affiliation
%
\author[T. Schumann et al.]{%
  T. Schumann\authref{a}\corref,
  W. Frings\authref{b},
  A. Peyser\authref{c},
  W. Schenck\authref{c},
  K. Thust\authref{b},
  J.M. Eppler\authref{c}
}

% --------------------------------------------------------------------------------
% Affiliations
% --------------------------------------------------------------------------------
\address{\authaddr{a}{Institute of Neuroscience and Medicine (INM-6), Computational and Systems Neuroscience \\ %
    Institute for Advanced Simulation (IAS-6) \\ %
    J\"ulich Aachen Research Alliance \\ %
    Forschungszentrum J\"ulich GmbH \\ %
    52425 J\"ulich, Germany}
  \authaddr{b}{J\"ulich Supercomputing Centre \\ %
    Institute for Advanced Simulation \\ %
    Forschungszentrum J\"ulich GmbH\\ %
    52425 J\"ulich, Germany}
  \authaddr{c}{Simulation Lab Neuroscience - Bernstein Facility for Simulation and Database Technology \\ %
    Institute for Advanced Simulation \\ %
    J\"ulich Aachen Research Alliance \\ %
    Forschungszentrum J\"ulich GmbH \\ %
    52425 J\"ulich, Germany}
}
%
% --------------------------------------------------------------------------------
% Email address of the corresponding author
% --------------------------------------------------------------------------------
\corauth{till.schumann@rwth-aachen.de}

% --------------------------------------------------------------------------------
% Abstract
% --------------------------------------------------------------------------------
\abstract{\textit{ NEST \cite{NEST} is a simulator for spiking neural
    networks. It runs on ordinary desktop computers and notebooks,
    small clusters and supercomputers. Storing
    simulation data efficiently is essential for neuroscientific
    studies but not trivial on supercomputers with centralized
    storage. To assess different I/O strategies and libraries, we have
    implemented a \emph{proxy} which imitates the writing behavior of
    NEST. This proxy allows benchmarking and statistical analysis, and
    thus consequent optimizations, without the complexity of running
    full NEST simulations.}}

% --------------------------------------------------------------------------------
% Keywords - must be separated by semicolon and no capital letters.
% --------------------------------------------------------------------------------
\keywords{parallel I/O; simulation; neuronal networks; supercomputer;
  threading; MPI}

% --------------------------------------------------------------------------------
% Beginning of document
% --------------------------------------------------------------------------------
\begin{document}

\maketitle

% --------------------------------------------------------------------------------
% Beginning of one section
% --------------------------------------------------------------------------------
\section{Introduction}
%
Over the past 20 years, the NEST Initiative \cite{NESTInitiative} has
developed the NEST simulator \cite{NEST} for spiking neural network
models. It is used in computational neuroscience to simulate the
dynamics of the interaction between nerve cells. The same code base is
used to simulate small networks on local machines up to large
brain-scale circuits using the full capabilities of the world's
leading supercomputers. The basis of this flexibility is a hybrid
parallelization scheme using threads locally and MPI to communicate
between the compute nodes.

To record and store simulation data, NEST uses virtual recording
devices. One instance of each of these devices (\emph{Spike detectors}
and \emph{Multimeters}) is created on each thread, and each instance
writes its data via a C++ stream to disk. For large-scale simulations
with many threads distributed over many compute nodes, this I/O
strategy fails, because of the large metadata overhead at the
filesystem level, e.g.~file creation alone can take up hours if a
supercomputer like JUQUEEN is fully used.

One solution used in recent releases of NEST has been the global spike
detector \cite{gsd}: a single file is opened by a dedicated MPI rank to
store spiking events, a low cost solution since currently all ranks
see all spike events through MPI collective communication.
On the other hand, the global spike detector has several long-term
consequences: 1) it constitutes a serialization bottleneck as spike
event I/O is handled by a single rank only without using all available
processors; 2) it is a design constraint requiring all spikes being
globally available, which may not be scalable; and 3) it is
inapplicable to more voluminous data (e.g. membrane potentials), which
is too much to be shipped to a single I/O node.

To overcome these problems, NEST requires an alternative approach to
file I/O. An important part of our efforts in this direction is the
specification and implementation of a \emph{NEST I/O proxy}, which
mimicks how NEST operates at the I/O level without actually executing
a full simulation. More specifically, it generates data writing
patterns similar to full NEST, but just with fake data. Thus, a large
part of the computational costs of full NEST simulations can be
avoided while developing and testing new I/O backends. Using this
proxy, we investigated possible performance gains by replacing the
current I/O paradigm with calls to parallelized I/O libraries, which
could avoid serialization bottlenecks, thus paving the road for better
I/O performance in NEST.

\section{Design of the NEST I/O proxy}

To develop new I/O strategies, information about the writing behavior
of NEST is necessary. In order to get this information, the main
algorithms of NEST were analyzed and the typical writing behavior was
estimated.

Given that NEST simulates an arbitrary neuronal network based on the
rules given in a simulation script, the program structure only gives
approximate and not exact information about the writing behavior. To
get the real runtime behavior, code analysis was accompanied by runtime
measurements for common use cases.

\subsection{Analysis of NEST code}

The main program structure of NEST can be reduced to an iteration loop
of gather, scatter and update functions of the network. Gather and
Scatter calls distribute the node states in the network. The update
function calls for each node internal algorithms, which process the
incoming information and update their state.

If the network node is a virtual recording device, it calls writing
functions depending on the incoming information. \emph{Spike
  detectors} handle spike events and \emph{Multimeters} request
internal parameters of node objects. Whether or not a writing call
occurs depends on the neuronal network structure and activity.

\subsection{Measurements of runtime behavior}

To generate reliable timing measurements of the runtime behavior, part
of the NEST code, in particular the functions of the virtual recording
devices and within them the calls to lower-level I/O functions, were
manually instrumented with Score-P \cite{ScoreP}.
%
We used the instrumented NEST binary to generate trace data for the
two use cases described in Sect.~\ref{sect:use_cases}.
From the trace data, we derived
statistical measures which describe the runtime behavior of NEST,
e.g.~the distribution of onsets of spike writing in each thread
relative to the start of the update phase in the main simulation cycle
of NEST.

\begin{table}[b]
\caption{Parameters which influence the I/O behavior of the proxy}
\centering
\begin{tabular}{lll}
\hline\hline
\textbf{Name}                   & \textbf{Type} & \textbf{Description} \\ \hline
numberOfSpikeDetectorsPerThread & Integer       & number of Spike detectors per thread  \\
numberOfMultimetersPerThread    & Integer       & number of Multimeters per thread  \\
spikesPerDetector               & Distribution  & number of spikes generated at each \\
        &           & Spike detector per iteration  \\
samplingIntervalsOfMeter        & Distribution  & sampling interval of the Multimeters  \\
numberOfValuesWrittenByMeter    & Distribution  & number of written values by each \\
        &           & Multimeter in sampling interval  \\
deadTimeUpdate                  & Distribution  & sleeping timings between Spike detectors' \\
        &           & and Multimeters' writing operations \\
deadTimeDeliver                 & Distribution  & sleeping time in deliver function  \\
\hline\hline
\end{tabular}
\label{tab:table-silva1}
\caption{Input parameters of the NEST I/O proxy. Following distributions
  are implemented: Normal, Poisson, Binominal and fixed values.}
\end{table}

\subsection{Working principles of the proxy}

The NEST I/O proxy contains three main parts: Construction of the
network, iteration loop and destruction of the network. In the first
part each node creates a set of \emph{Spike detector} and
\emph{Multimeter} objects. Their numbers and properties are given by
the parameters shown in Table \ref{tab:table-silva1}. The iteration
loop contains a sleep function, parameterized by the distribution
\emph{deadTimeDeliver}, and update functions for the recording
devices, which also execute a sleep function, parameterized by the
distribution \emph{deadTimeUpdate}. During the update function each
\emph{Spike detector} or \emph{Multimeter} object calls one or more
write functions.

\begin{figure}[tb]
\centering %
\begin{subfigure}[b]{0.5\textwidth}
                \includegraphics[width=.85\linewidth]{loggerinterface.eps}
                \caption{ILogger implements the I/O interface for the virtual
			recording devices.  Three differenct logger interfaces are
			available: \emph{ASCIILogger}, \emph{SIONLogger}, and
			\emph{HDF5Logger} (see section \ref{sec:io-drivers} for details). \cite{yuml}}
                \label{fig:loggerinterface}
        \end{subfigure}%
        \begin{subfigure}[b]{0.5\textwidth}
	      \includegraphics[width=.85\linewidth]{ascii_plot_10_8.eps}
	      \caption{NESTProxy output (used microcircuit model parametrization) plots the measured writing timings of the ASCII driver over internal iteration loop number.
	      \cite{yuml}}
	      \label{fig:asciiplot}
        \end{subfigure}%


\end{figure}

%\includegraphics[scale=0.5]{loggerinterface.eps}
%\caption{ILogger implements the I/O interface for the virtual
%  recording devices.  Three differenct logger interfaces are
%  available: \emph{ASCIILogger}, \emph{SIONLogger}, and
%  \emph{HDF5Logger} (see section \ref{sec:io-drivers} for details). \cite{yuml}}
%\label{fig:loggerinterface}

\subsection{Basic I/O driver interface}

To provide maximum flexibility regarding the output format and to support all 
use cases of NEST, an interface (see Fig.~\ref{fig:loggerinterface}) was 
developed that connects the virtual recording devices with different I/O 
libraries, and that allows easy selection between them.


\section{Currently implemented I/O drivers}
\label{sec:io-drivers}

Based on the interface described above, three different drivers were
implemented.

\paragraph{ASCII}

NEST currently uses C++ streams to store results as plain text files
containing time stamps as floating point strings. This scheme is
self-descriptive and simple to implement for post-processing and
analysis tools.
%
However for large-scale simulations it leads to: 1) excessively large
amounts of data written to disk, which is both a performance issue and
a practical storage problem; 2) a serialization bottleneck when
opening a separate file per virtual recording device; and 3) a
serialization bottleneck for metadata updates in the file system when
new blocks are allocated.
%\pleasewrite{Alex}{The ASCII driver has for each virtual recording
%  device a file. The virtual recording devices live on the task.}
Neverthess, We will still used an ``ASCII'' driver as a benchmark against other
approaches, for debugging and validating other drivers, and as an
interface allowing backwards compatibility.

\paragraph{HDF5}

HDF5 is an API commonly used for file formats in the neuroscience
community, such as NEO \cite{neo} and Neuroshare \cite{neuroshare}.
Since they use a common binary layout and API, data can be accessed
from many different languages and through many different libraries.
The HDF group publishes pHDF5 (parallel HDF5, \cite{hdf5}) which
allows read and write access to HDF5 files over MPI.

HDF5 is a highly structured, self-describing format intended for
long-term accessibility and versatile usage. This comes at the cost of
significant amounts of metadata to describe the data layout, creating
a collective barrier when finite data structures are extended. In
short, pHDF5 is read-oriented rather than write-oriented, with some of
the same drawbacks (and advantages) as the ASCII driver.

%For writing the data from large neuronal networks simulated in NEST,
%we have found it difficult to achieve a performance similar to what we
%got with SIONlib.

\paragraph{SIONlib}

SIONlib \cite{frings2009scalable} is a library which addresses most of
the common problems that arise from large scale parallel I/O. Its API
resembles task-local file I/O which makes it easy to replace the
existing ASCII driver in NEST.

Compared to HDF5, SIONlib's API is simpler since it does not describe
the data that is written, but only offers an interface for writing
byte steams, similar to ANSI-C. In general it focuses on performance
and simplicity and leaves the interpretation of the data to the user.

The most common write strategy in SIONlib only uses collective
operations to open and close files while the read and write calls are
independent and do not need any communication. This method is highly
scalable but uses file system block alignment to achieve better
performance and thus results in a significant amount of unused space
for scenarios where the volume of data per task is very small, which
is potentially the case for NEST. Hence for this case the collective
writes in SIONlib are preferable.

\section{Benchmarking}

\subsection{Benchmark simulations}\label{sect:use_cases}

For benchmarking,
we used two typical simulation tasks. First, the
simulation of a random balanced network \cite{morrison07}, second the
microcircuit model of a cubic millimeter of cortex \cite{potjans14}.
The first has very balanced I/O requirements, while the latter is very
close to typical production runs carried out by the neuroscience
community.

To collect runtime data for the parametrization of the NEST I/O proxy,
the random balanced network was run on a single compute
node of the supercomputer JUQUEEN, being split over 16 threads, while
the simulation of the microcircuit model was distributed over 32
compute nodes on JUQUEEN with eight threads each; the overall number
of neurons amounted to 80,000. Both \emph{Spike detectors} and \emph{Multimeters}
were used as recording devices.

\subsection{Results}

A final benchmark run shows the possibilities of the NESTProxy.
Using the parametrization of a typical simulation (see \ref{sect:use_cases}),
the NESTProxy is run with the current NEST implemenation 
%(1) The current ASCII implemenation from NEST, (2) a standard sionlib implementation and (3) a sionlib implemenations which buffers before writting.
The NESTProxy is executed on an Intel Xeon cluster. $10$ compute nodes and $10$ threads per compute node were used. 

Mimicking the mircocircuit simulation described above with the NEST I/O proxy, we obtained
the benchmark results for the current NEST implemenation shown in Fig.~\ref{fig:asciiplot}.

The current I/O \emph{ASCII} implementation of NEST produces a large variation of writing timings.
Besides the the high values (up to $0.2$ seconds) it causes problems for workload optimizations.

% \begin{itemize}
%   \item{Random balanced network: Dry-run simulation for M=32, T=16, N=300,000, mean firing frequ. of 7 Hz}
%   \item{Microcircuit model: Real simulation of only one area, run over 1000.0 ms: \\
% - Number of MPI processes: 32\\
% - Number of threads per MPI process: 8\\
% - Number of virtual processes (VPs): 256 (32x8)\\
% - Number of spike detectors per VP: 8\\
% - Number of neurons attached to each spike detector: 10000/256 (ca.)\\
% - Number of multimeters per VP: 8\\
% - Number of neurons attached to each multimeter: 500/256\\
% - MinDelay interval: Most likely equal to h step (= 0.1 ms)\\
% - Overall number of neurons in the network: 80,000}
% \end{itemize}

\section{Conclusions}

The NEST I/O proxy presented allows developers to flexibly switch
between several backends with different performance characteristics
and use-case profiles. It proved to be a good tool for profiling and
benchmarking NEST's I/O over a range of parameters without the
computational and developmental overhead required to cover the same
range of possibilities using production runs of NEST.

Additionally, the proxy can be used as a generic tool for benchmarking
I/O strategies in general, given that NEST is a leading neuronal
network simulators with performance characteristics determined by the
same constraints also affecting other similar software packages (e.g.,
NEURON \cite{neuron} or Brian \cite{brian}).

\section*{Acknowledgments}

Partially funded by the Helmholtz Association through the Helmholtz
Portfolio Theme "Supercomputing and Modeling for the Human Brain".
\pleasewrite{Till}{funded by the BBP of EPFL}


% --------------------------------------------------------------------------------
% Bibliography
% --------------------------------------------------------------------------------
\begin{thebibliography}{99}

\bibitem{NESTInitiative} NEST Initiative: The Neural Simulation
  Technology Initiative. \url{http://www.nest-initiative.org}.

\bibitem{NEST} %
  M.~Gewaltig, M.~Diesmann. NEST (NEural Simulation
  Tool). \textit{Scholarpedia} %
  \textbf{2.4}:1430, 2007.

\bibitem{gsd} S.~Kunkel et al. Spiking network simulation code for
  petascale computers.  \textit{Front.~Neuroinform.} \textbf{8}:78,
  2014.

\bibitem{ScoreP} Andreas Kn\"upfer et al. Score--P --- A Joint
  Performance Measurement Run--Time Infrastructure for Periscope,
  Scalasca, TAU, and Vampir. In: \textit{Proc.~of 5th Parallel Tools
    Workshop}, pp.~79--91, 2012.

\bibitem{neo} S.~Garcia et al. NEO: an object model for handling
  electrophysiology data in multiple formats.
  \textit{Front.~Neuroinform.}, \textbf{10}:8, 2014.
% \bibitem{neo} S.~Garcia, D.~Guarino, F.~Jaillet, T.~Jennings,
%   R.~Pr{\"o}pper, P.L.~Rautenberg, C.C.~Rodgers, A.~Sobolev,
%   T.~Wachtler, P.~Yger. NEO: an object model for handling
%   electrophysiology data in multiple formats.
%   \textit{Front.~Neuroinform.}, \textbf{10}:8, 2014.

\bibitem{neuroshare} The Neuroshare Project: Neuroshare Home
  Page. \url{http://neuroshare.sourceforge.net}.

\bibitem{hdf5} The HDF Group: HDF5 Home
  Page. \url{http://www.hdfgroup.org/HDF5/PHDF5}.

\bibitem{frings2009scalable} W.~Frings, F.~Wolf, V.~Petkov. Scalable
  massively parallel I/O to task-local files.  In: \textit{Proc.~of
  the Conference on High Performance Computing, Networking,
    Storage and Analysis}, article No.~17, 2009.

\bibitem{morrison07} A.~Morrison, A.~Aertsen,
  M.~Diesmann. Spike-timing-dependent plasticity in balanced random
  networks. \textit{Neural Computation} \textbf{19.6}:1437--1467,
  2007.

\bibitem{potjans14} T.C.~Potjans, M.~Diesmann. The cell-type specific
  cortical microcircuit: relating structure and activity in a
  full-scale spiking network model. \textit{Cereb.~Cortex}
  \textbf{24}:785--806, 2014.

\bibitem{neuron} M.~L.~Hines, N.~T.~Carnevale. The NEURON simulation
  environment. \textit{Neural Computation} \textbf{9.6}: 1179--1209,
  1997.

\bibitem{brian} D.~F.~M.~Goodman, R.~Brette. The Brian
  simulator. \textit{Front.~Neurosc.} \textbf{3.2}:192--197, 2009.
  
\bibitem{yuml} yUML: The diagram is generated by yUML. \url{http://yuml.me}

\end{thebibliography}

\end{document}
